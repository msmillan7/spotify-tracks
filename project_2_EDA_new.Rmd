---
title: "Spotify Tracks Popularity - Exploratory Data Analysis"
author: "Richard Bridges, Conor Welch and Marina Sanchez"
date: "11/6/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction
Have you ever thought about what characteristics popular songs share?
Music is something that everybody listens to. It exists in a variety of different forms and genres and is an art form that people resonate with on a very personal level. This makes it especially interesting to analyze as not just a cultural product, but also, thanks to modern-day analytics, as a data product. Companies such as Spotify have pioneered this kind of analysis and music curation.
In this analysis, we will explore how the content of songs, both lyrically and musically, and its regional availability, determine the popularity of the track.


```{r}
#install.packages("dplyr")
#install.packages("viridis")  
#install.packages("corrr") 
library("viridis")
library(dplyr)
library(tidyverse)
library(ggpubr)
library(Matrix)
library(qdapDictionaries)
library(readxl)
library(ggplot2)
library(RColorBrewer)
library(stringr)
library(stringr)
```


## Data import and measurement of completeness

The first step is to retrieve the NAs and empty values contained in the data set
```{r}

#read in data and check for NaNs
df <- read.csv("spotify_tracks.csv")

#apply(df, 2, function(x) sum(is.na(x)))
apply(df, 2, function(x) sum(is.finite(x)))
apply(df, 2, function(x) sum(is.na(x) | x == ''))

```

As we can see, the data set is complete.

## Scaling and Normalization

In this section we are cleaning the data by retrieving only the data of interest and performing some normalization process on the values. The main attributes (metrics) of interest are the following:

1. Popularity: numeric measure of popularity of song from Spotify (Spotify’s own calculation of popularity likely based on a variety of factors such as number of streams, unique streams, etc.).

2. Danceability: how suitable a track is for dancing based on a combination of musical elements including tempo, rhythm stability, beat strength, and overall regularity (low 0 to high 1).

3. Energy: perceptual measure of intensity and activity. Typically, energetic tracks feel fast, loud, and noisy. For example, death metal has high energy, while a Bach prelude scores low on the scale. Perceptual features contributing to this attribute include dynamic range, perceived loudness, timbre, onset rate, and general entropy.

4. Key: The estimated overall key of the track. Integers map to pitches using standard Pitch Class notation . E.g. 0 = C, 1 = C?/D?, 2 = D, and so on. If no key was detected, the value is -1.

5. Speechiness: presence of spoken words in a track. The more exclusively speech-like the recording (e.g. talk show, audio book, poetry), the closer to 1.0 the attribute value.

6. Acousticness: a confidence measure from 0.0 to 1.0 of whether the track is acoustic. 1.0 represents high confidence the track is acoustic.

7. Instrumentalness: predicts whether a track contains no vocals. “Ooh” and “aah” sounds are treated as instrumental in this context. Rap or spoken word tracks are clearly “vocal”. The closer the instrumentalness value is to 1.0.

8. Valence: a measure from 0.0 to 1.0 describing the musical positiveness conveyed by a track. Tracks with high valence sound more positive (e.g. happy, cheerful, euphoric), while tracks with low valence sound more negative (e.g. sad, depressed, angry).

9. Liveness: Detects the presence of an audience in the recording. Higher liveness values represent an increased probability that the track was performed live. A value above 0.8 provides strong likelihood that the track is live.

10. Loudness: The overall loudness of a track in decibels (dB). Loudness values are averaged across the entire track and are useful for comparing relative loudness of tracks. Loudness is the quality of a sound that is the primary psychological correlate of physical strength (amplitude). Values typical range between -60 and 0 db.

11. Duration: Duration of the track.

12. Tempo: overall estimated tempo of a track in beats per minute (BPM).

13. Lyrics

14. Available markets: Regions where the song is available

```{r}
## Scatterplots for infinite variables vs popularity

tracks.df <- df[,c("acousticness", "danceability", "available_markets", "country", "duration_ms", "energy", "instrumentalness", "liveness", "loudness", "lyrics", "speechiness", "valence", "key", "tempo", "popularity", "id")]


# data transformations
tracks.df$popularity <- tracks.df$popularity/100
tracks.df$duration_scaled <- tracks.df$duration_ms/5505831
tracks.df$loudness_scaled <- (tracks.df$loudness + 60)/62.719

# Rewrite dataframe with transformed values
tracks.df <- tracks.df[,c("acousticness", "danceability", "available_markets", "country", "duration_scaled", "energy", "instrumentalness", "liveness", "loudness_scaled", "lyrics", "speechiness", "valence", "key", "tempo", "popularity", "id")]

```

The data set underwent the following transformations:
1.  Popularity was scaled down so that each observation fell between 0 and 1.
2.  Duration was scaled by dividing by the longest track in the data set (5505831 ms) so that each play times, similarly, fell between 0 and 1.
3.  Loudness was scaled by first adding 60 to all the observations.  This has the effect of converting all the observations to positive numbers since the lowest loudness score in the category is -60.  All numbers in the column were then divided by 62.719, the maximum value in the column after adding 60 to all the values.  This process scales all observations to values between 0 and 1.


## Correlation between popularity and quantitative variables

```{r}
library(dplyr)
library(corrr)
library(ggplot2)

# Include on columns with continuous quantitative data
tracks_onlycontinuous.df <- subset(tracks.df, select = -c(lyrics, country, available_markets, key, id))

# Create bar chart of pearson correlation scores
tracks_onlycontinuous.df %>% correlate() %>% focus(popularity) %>%
  ggplot(aes(x = term, y = popularity)) +
  ggtitle("Correlation Between Popularity and Categories\n
    of Quantitative Variables") +
    geom_bar(stat = "identity") +
    ylab("Pearson Correlation") +
    xlab("Variable") +
    ylim(-1, 1) +
    geom_col(aes(fill = popularity)) + 
    scale_fill_gradient2(low = "blue", 
                       high = "red", 
                       mid = "white",
                       midpoint = median(0))+
    theme(
      legend.position = "none",
      plot.title = element_text(size = 16, hjust = 0.5),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(angle = 45, vjust = 1, 
        size = 12, hjust = 1),
      axis.title.y = element_text(size = 14),
      axis.title.x = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      axis.ticks = element_blank()
    )
```

Our initial objective was to explore the data and find which categories, if any, correlated with popularity.  Perhaps as to be expected with a topic as subject to personal tastes and as varied in its presentation and interpretability as music, there were no correlations between popularity and any of the quantitative variables in the data set.  Because there were both so many categories and observations in the data set, pairwise correlation plots would not have been a feasible graphical presentation of association as the details of the plots would have been obscured.  Instead, a bar graph of r^2 values is presented that shows the degree of correlation between the quantitative variables in the data set and popularity.


## Popularity association with key (a categorical variable)

```{r}
# Key was left out of previous plot because it is a discrete variable

keys <- c("C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B")

# Violin plot of keys vs. popularity
ggplot(tracks.df, aes(factor(key), popularity)) + 
  ggtitle("Correlation Between Popularity and Key", ) +
    ylab("Popularity") +
    xlab("Key") +
  geom_violin(fill = 'sienna1', scale = 'count') + 
  geom_point(shape = 1, colour = "black", fill = "white", size = 0.01) +
  scale_x_discrete(labels= keys) +
  theme(legend.position = "none",
        panel.background = NULL,
        plot.title = element_text(size = 16, hjust = 0.5),
        axis.text.y = element_text(size = 12),
        axis.text.x = element_text(size = 12),
        axis.title.y = element_text(size = 14),
        axis.title.x = element_text(size = 14)
        )
```

In addition to the correlation analyses described above, the degree of popularity as a function of musical key (a discrete variable) was also examined.  Here a violin plot is presented of the degree of popularity of songs in the 12 keys of a musical octave.  Quite surprisingly, the average degree of popularity of any one key or keys was not much greater than that of any other key, though the range of popularities for some keys were wider than others.  An interesting feature of the geom_violin object is the option to pass 'scale = "count"' as an argument, which sizes the width of an individual plot in proportion with the number of observations corresponding to its categorical variable.  In this plot, one can observe that the most common keys for songs in the database are C, D, G, and A while the least common keys are D#, G#, and A#.

## Correlation between quantitative variables (all observations)

```{r}
library(reshape2)
library(ggplot2)

# subset tracks to include only continuous variables
tracks_onlycontinuous.df <- subset(tracks.df, select = -c(lyrics, country, available_markets, key, tempo, id))

# Create correlation table
tracks_cor <- round(cor(tracks_onlycontinuous.df, tracks_onlycontinuous.df), 2)

# Get upper triangle of the correlation matrix
get_upper_tri <- function(tracks_cor){
  tracks_cor[lower.tri(tracks_cor)]<- NA
  return(tracks_cor)
}
  
# Apply get_upper_tri to tracks_cor
upper_tri <- get_upper_tri(tracks_cor)

# Melt the correlation matrix
tracks_melt <- melt(upper_tri, na.rm = TRUE)

# Create a ggheatmap
ggplot(tracks_melt, aes(Var2, Var1, fill = value))+
  geom_tile(color = "white")+
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
    midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
ggtitle("Correlation Between Numerical Categories") +
geom_text(aes(Var2, Var1, label = value), color = "black", size = 3) +
theme(
  plot.title = element_text(hjust = 0.5),
  axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 10, hjust = 1),
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.justification = c(1, 0),
  legend.position = c(0.6, 0.7),
  legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                title.position = "top", title.hjust = 0.5))
```

This figure examines the pairwise correlation between all categories in the data set, not just popularity.  The data is presented in a heat map with correlation coefficients appearing inside each of the boxes.  Red coloration indicates a positive correlation while blue coloration indicates a negative correlation.  Energy and acousticness have a negative -0.72 correlation, loudness and energy have a 0.78 correlation, lyrics and instrumentalness have a 0.51, loudness and acousticness have a -0.58, and valence and danceability have a 0.52.

## Comparison of quantitative variables in subsets of most popular and least popular tracks

```{r}
library(tidyr)
library(dplyr)

# Take top 5 most popular tracks in tracks.df
pop_95.df <- tracks.df %>%
  select(-c(lyrics, country, available_markets, key, tempo)) %>%
  filter(popularity > quantile(popularity, 0.95))

# Take bottom 5 least popular tracks in tracks.df
pop_5.df <- tracks.df %>%
  select(-c(lyrics, country, available_markets, key, tempo)) %>%
  filter(popularity < quantile(popularity, 0.05))

# Create column place that identifies each dataframe as either top 5 or bottom 5
pop_95.df$place <- 'top_5'
pop_5.df$place <- 'bottom_5'

# Combine the two data frames vertically
pop.df <- rbind(pop_95.df, pop_5.df)

# Graph boxplot
pop.df %>% 
  pivot_longer(., cols = c(acousticness, danceability, duration_scaled, energy, instrumentalness, liveness, loudness_scaled, speechiness, valence, popularity), names_to = "Var", values_to = "Val") %>%
  ggplot(aes(x = Var, y = Val, fill = place)) +
  ggtitle("Category Scores for Top 5% vs.\n
  Bottom 5% Most Popular Tracks") +
  geom_boxplot() +
  theme(
  plot.title = element_text(hjust = 0.5, size = 18),
  axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 10, hjust = 1),
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  legend.title = element_blank(),
  ) +
  scale_fill_manual(values=c('sienna1', 'mediumpurple1'))

```

Because there was not a great deal of correlation between variables that would lead to any sort of interesting examination when considering the entire set of observations, the decision was made to contrast data between two populations within the data set.  Instead of considering the data set in its entirety, this figure subsets the tracks into the top 5 percentile and bottom 5 percentile in terms of popularity and compares them to each other on the same set of quantitative variables examined in the first figure.  When comparing the top 5 and bottom 5 most popular tracks a number of interesting differences arises.  The top 5 tracks tend to score less in acousticness and speechiness but more in energy and loudness.  The distribution of data points in some of the categories is also quite intriguing.  There are many categories for which most of the observations are confined to a narrow band with many outliers appearing above or below that band.  For example, while the average play times of the most popular tracks and least popular tracks are fairly similar and tend towards the lower end of the scale, the outliers for the two groupings are quite different.  The outliers for the most popular tracks appear in a cluster in close proximity to the average but the outliers for the least popular tracks stretch far above the average.  For both the popular and unpopular songs, average instrumentalness ratings hover close to zero but outliers can streth all the way to one.

## Tracks Lyrics vs. Popularity Analysis

The main purpose of this section is to perform an analysis of the most frequent words contained in the lyrics of the songs.
First, we have retrieved the most common words of all the songs contained within the data set.
Then, we have performed the same process but considering only the top 100 most popular songs of the data set.

```{r}
#Import Libraries
library(ggpubr)
library(Matrix)
library(qdapDictionaries)
library(readxl)

#Create dataframe with only the data in lyrics, id and popularity columns
df.lyrics <- tracks.df %>% 
  select(lyrics, id, popularity)

#Preprocessing: lowercasing, smooshing contractions, removing punctuation, numbers, and getting rid of extra spaces
df.lyrics <- df.lyrics %>% 
  dplyr::mutate(
    clean_text = tolower(lyrics),
    clean_text = gsub("[']", "", clean_text), 
    clean_text = gsub("[[:punct:]]", " ", clean_text),
    clean_text = gsub('[[:digit:]]+', " ", clean_text),
    clean_text = gsub("[[:space:]]+", " ", clean_text),
    clean_text = trimws(clean_text))

#Read stop words list, that contains prepositions, articles and pronouns to be removed from the lyrics
df.stop_words <- read_excel("stop_words.xlsx")
stop_words <- c(df.stop_words$words)
```

In this first section, we have retrieved the columns of interest for this study (lyrics, id and popularity) from the main data frame.
Then we have perform some transformations on the lyrics column.
  1. Convert all characters to lowercase
  2. Remove punctuation
  3. Remove numbers
  4. Remove extra spaces
  5. Remove Leading/Trailing spaces

Finally, we have read a file that contains the words that we don't want to take into account in the analysis process, such as prepositions, articles and pronouns. We will use this data for filtering only the words of interest to be analysed.

### Most frequent words
For counting the number of occurrences of each in each of the tracks, we have parsed the "lyrics" column of the dataframe. 

  1. For each of the tracks, we have split the lyrics word by word (tokens) and stored them into a list.
  2. Once we have all the lyrics split and stored word by word, we have removed those tokens that either are not in the English dictionary or are contained within the stop-words list imported above.
  3. Once we only have the meaningful tokens, we have used a document term matrix that has the following structure:
    - Rows: Each row i belongs to a track is.
    - Columns: Each column j contains a token (word)
    - Each position of the matrix [ij] contains how many times the word in column j appears in track of row i

```{r}
#Convert lyrics into a Document Term Matrix that counts the number of times that each words appear

text <- df.lyrics$clean_text
doc_id <- df.lyrics$id

#Convert the lyrics of each entry into a list of words (tokens)
tokns <- strsplit(text, " ", fixed=TRUE)
# 
# # Clean tokens before inserting in the matrix
# for (i in 1:length(tokns)){
#   current <- tokns[[i]]
#   # Retrieve only the words contained within the English dictionary
#   current <- current[current %in% GradyAugmented]
#   # Retrieve only meaningful words (clean stop-words: prepositions, articles and pronouns)
#   current <- current[!current %in% stop_words]
#   # Replace into original list of tokens
#   tokns[[i]] <- current
# }
# 
# #Create Document Term Matrix:
# # Rows: Tracks
# # Columns: Words
# # Each position of the matrix [ij] contains how many times the word in column j appears in track of row i
# vocab <- sort(unique(unlist(tokns)))
# dtm <- matrix(data = 0L,
#               ncol = length(vocab), nrow = length(tokns),
#               dimnames = list(doc_id, vocab) )
# freqs <- lapply(tokns, table)
# for (i in 1:length(freqs) ){
#   doc <- freqs[[i]]
#   dtm[i, names(doc)] <- as.integer(doc)
# }

```

The following barplot shows the top 25 words with more occurrences in the lyrics, taking into consideration all the songs within the data set.
```{r}
#install.packages("RColorBrewer")
library(RColorBrewer)

#Count the total number of occurrences of each word
# words_count <- colSums(dtm)
# #Sort words per number of occurrences
# words_count <- sort(words_count, decreasing=TRUE)
# 
# #Get the first 25 words (most occurrences)
# top_25_words <- words_count[0:25]
# 
# # Plot the most frequent words contained in the songs
# barplot(sort(top_25_words[1:20]), 
#         ylab = "Words",
#         xlab = "Words frequencies",
#         xlim = c(0,1600),
#         horiz = T,
#         las = 1,
#         names.arg = names(sort(top_25_words[1:20])),
#         col = brewer.pal(20, "Pastel1"),
#         main = "Top 25 words in songs",
#         cex.names = 0.7)
```

The wordcloud below shows the top 100 words used in the songs, with larger words meaning more occurrences. 
```{r}
#Generate word-cloud graph

#install.packages("wordcloud")
#install.packages("RColorBrewer")
#install.packages("wordcloud2")
library(wordcloud2)
library(RColorBrewer)
library(wordcloud)

# top_100_words <- words_count[0:100]
# df.top_100_words <- data.frame(keyName=names(top_100_words), 
#                                count=top_100_words, row.names=NULL)
# 
# wordcloud(words = df.top_100_words$keyName, freq = df.top_100_words$count, min.freq = 1,
#           max.words=200, random.order=FALSE, rot.per=0.35, 
#           colors=brewer.pal(8, "Dark2"))
```


### Most frequent words in Top 100 popular songs

For this section, we have followed the same approach, but this time taking into consideration only the 100 most popular songs of the dataset.
```{r}
#Arrange dataset according to popularity
df.popular <- df.lyrics %>% 
  arrange(desc(popularity))

#Get top 100 popular songs
df.popular_top_100.lyrics <- df.popular[1:100,] %>% 
  select(clean_text, id, popularity)
```

Again, we have build a document term matrix to store the number of occurrences of each word per track.
```{r}
#Convert lyrics into a matrix that counts the number of times that the words appear

text_pop <- df.popular_top_100.lyrics$clean_text
doc_id_pop <- df.popular_top_100.lyrics$id

#Convert the lyrics of each entry into a list of words (tokens)
tokns_pop <- strsplit(text_pop, " ", fixed=TRUE)

# Clean tokens
for (i in 1:length(tokns_pop)){
  current <- tokns_pop[[i]]
  # Retrieve only the words contained within the English dictionary
  current <- current[current %in% GradyAugmented]
  # Retrieve only meaningful words (clean stop-words: prepositions, articles and pronouns)
  current <- current[!current %in% stop_words]
  # Replace into original list of tokens
  tokns_pop[[i]] <- current 
}

vocab_pop <- sort(unique(unlist(tokns_pop)))
dtm_pop <- matrix(data = 0L, 
              ncol = length(vocab_pop), nrow = length(tokns_pop),
              dimnames = list(doc_id_pop, vocab_pop) )
freqs_pop <- lapply(tokns_pop, table)
for (i in 1:length(freqs_pop) ){
  doc <- freqs_pop[[i]]
  dtm_pop[i, names(doc)] <- as.integer(doc)
}
```

The following bar plot and word-cloud graphs show the most common words used in the top 100 popular songs
```{r}

words_count_pop <- colSums(dtm_pop)
words_count_pop <- sort(words_count_pop, decreasing=TRUE)
#head(words_count_pop)
top_100_words_pop <- words_count_pop[0:100]

# Plot the most frequent words contained in the most popular songs
barplot(sort(top_100_words_pop[1:20]), 
        ylab = "Words",
        xlab = "Words frequencies",
        xlim = c(0,500),
        horiz = T,
        las = 1,
        names.arg = names(sort(top_100_words_pop[1:20])),
        col = brewer.pal(20, "Pastel2"),
        main = "Top 20 words in most popular songs",
        cex.names = 0.7)
```

```{r}
#Generate word-cloud graph

df.top_100_words_pop <- data.frame(keyName=names(top_100_words_pop), 
                                   count=top_100_words_pop, row.names=NULL)

wordcloud(words = df.top_100_words_pop$keyName, freq = df.top_100_words_pop$count, min.freq = 1,
          max.words=200, random.order=FALSE, rot.per=0.35, 
          colors=brewer.pal(8, "Dark2"))
```

The bar plot and the wordcloud above show the top words in top 100 popular songs (with larger words meaning more occurrences in the wordcloud). 
It makes sense to find the words "yeah" and "oh" as the most frequent, based on the style and content of the songs that we can hear on the radio nowadays.
On the other hand, love has always been the main topic in most of popular songs, so we are not surprised about finding "Love" as one of the most frequent words. Many of the other popular words are pretty commonly found words that follow the theme of “love”. “Like” and “baby”, "kiss", "Need" are also high on the list as they also fall into this general romance bucket.
Most of the other top words are pretty common words: want, know, come, cause, make, get, etc. A lot of these tend to be verbs that connect parts of lyrics and likely occur at higher rates because they are short and easy to use in lyrics. Other words such as “eh” and “hey” are common filler words.

## Analysis of Country's Effect on Popularity

The entries in the available markets variable is originally a list saved as a string in the form `{r} tracks.df$available_markets[[3]]`. To provide analysis on this variable we must first convert each entry from a string to a list of strings.

```{r}
## Changing the Available_Markets variable to lists of strings

x <- tracks.df$available_markets

x <- str_replace_all(x, "\\[", "") 
x <- str_replace_all(x, "'", "") 
x <- str_replace_all(x, "]", "") 
x <- str_split(x, pattern =', ')

tracks.df$countries_list <- x

tracks_onlycontinuous.df <- subset(tracks.df, select = -c(lyrics, country, available_markets, key, countries_list, id))
```

We then look at which countries appear most often in the dataset.

```{r}
## Finding how often a country shows up
countries <- tracks.df$countries_list
freq_country <- as.data.frame(table(unlist(countries)))
names(freq_country)[1:2] <- c("Country", "Frequency")
freq_country <- freq_country[order(-freq_country$Frequency),]
rownames(freq_country) <- 1:79
freq_country$Country <- as.character(freq_country$Country)

## Plot of Occurences

freq_country_cut <- cut(freq_country$Frequency, breaks = quantile(freq_country$Frequency, c(0, .2, .4, .6, .8, 1)), include.lowest = TRUE)
plot(freq_country_cut)

ggplot(freq_country, aes(x = factor(Country, levels = (Country)), y = Frequency, fill = freq_country_cut))  +
  ggtitle("Occurrences of Countries in Available Markets") +
    ylab("Frequency") +
    xlab("Country") +
  geom_bar(stat = "identity", color = "black") +
  scale_fill_brewer(palette = "Oranges") +
  coord_cartesian(ylim = c(75000, 95000)) +
  theme(
    legend.position = "none",
    plot.title = element_text(size = 16, hjust = 0.5),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(angle = 45, vjust = 1, 
                               size = 12, hjust = 1),
    axis.title.y = element_text(size = 14),
    axis.title.x = element_text(size = 14),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.ticks = element_blank()
  )
```

As we can see Denmark shows up the most, with roughly 95000 occurrences, and India shows up the least, at roughly 78000 occurrences.

### Checking Popularity Against 5 Most and Least Occurring Markets

We now want to subset the data based on whether a track is available in at least one of the top 5 countries by appearance, is available in all top 5 or is available in at least one of the bottom 5 countries. Then we look at what effect this has on the average popularity of the tracks in each group along with the Pearson correlation of each variable with respect to popularity. The first plot is the value of these attributes for each group and includes the corresponding values from the total data set. For visualization, the second plot is the difference of each group's attributes from the total data set.

```{r}
## Subsetting into lists of top 5 countries and bottom 5 countries

top_5_country <- subset(freq_country$Country, freq_country$Frequency >= freq_country$Frequency[freq_country$Country == "IS"])
bot_5_country <- subset(freq_country$Country, freq_country$Frequency <= freq_country$Frequency[freq_country$Country == "AU"])


## Top 5 Countries
top_5_indicator <- c()

for (entry in 1:length(countries)){
 top_5_indicator <- c(top_5_indicator, sum(top_5_country %in% tracks.df$countries_list[[entry]]) >= 1)
}

tracks_top5country.df <- filter(tracks.df, top_5_indicator)

tracks_top5_onlycontinuous.df <- subset(tracks_top5country.df, select = -c(lyrics, country, available_markets, key, countries_list, id))

### Analysis of subsetting and effect on popularity
top_5mean <- mean(tracks_top5_onlycontinuous.df$popularity)
top_5mean_diff <- abs(mean(tracks_onlycontinuous.df$popularity) - top_5mean)

cor_tracks <- cor(tracks_onlycontinuous.df, tracks_onlycontinuous.df$popularity)
cor_top_5 <- cor(tracks_top5_onlycontinuous.df, tracks_top5_onlycontinuous.df$popularity)

top_5cor <- cor_tracks - cor_top_5

## If an entry has all 5 top countries

bt_5_indicator <- c()

for (entry in 1:length(countries)){
  bt_5_indicator <- c(bt_5_indicator, sum(top_5_country %in% tracks.df$countries_list[[entry]]) ==5)
}

tracks_bt5country.df <- filter(tracks.df, bt_5_indicator)

tracks_bt5_onlycontinuous.df <- subset(tracks_bt5country.df, select = -c(lyrics, country, available_markets, key, countries_list, id))

### Analysis of subsetting and effect on popularity
bt_5mean <- mean(tracks_bt5_onlycontinuous.df$popularity)
bt_5mean_diff <- abs(mean(tracks_onlycontinuous.df$popularity) -  bt_5mean)

cor_bt_5 <- cor(tracks_bt5_onlycontinuous.df, tracks_bt5_onlycontinuous.df$popularity)

bt_5cor <- cor_tracks - cor_bt_5

## Bottom 5 Countries

bot_5_indicator <- c()

for (entry in 1:length(countries)){
  bot_5_indicator <- c(bot_5_indicator, sum(bot_5_country %in% tracks.df$countries_list[[entry]]) >= 1)
}

tracks_bot5country.df <- filter(tracks.df, bot_5_indicator)

tracks_bot5_onlycontinuous.df <- subset(tracks_bot5country.df, select = -c(lyrics, country, available_markets, key, countries_list, id))

### Analysis of subsetting and effect on popularity

bot_5mean <- mean(tracks_bot5_onlycontinuous.df$popularity)
bot_5mean_diff <- abs(mean(tracks_onlycontinuous.df$popularity) - bot_5mean)

cor_bot_5 <- cor(tracks_bot5_onlycontinuous.df, tracks_bot5_onlycontinuous.df$popularity)

bot_5cor <- cor_tracks - cor_bot_5

## Plot of the correlations versus popularity and mean of popularity against each data set

comptracks.df <- data.frame(row.names(top_5cor), cor_top_5, cor_bt_5, cor_bot_5, cor_tracks)
new_comptracks.df <- rbind(comptracks.df, c("mean", top_5mean, bt_5mean, bot_5mean, mean(tracks_onlycontinuous.df$popularity)))
row.names(new_comptracks.df)[1:11] <- 1:11
names(new_comptracks.df) <- c("Category", "Top_5", "All_5", "Bottom_5", "All")

new_comptracks.df <- transform(new_comptracks.df[-11,], Top_5 = as.numeric(Top_5), All_5 = as.numeric(All_5), Bottom_5 = as.numeric(Bottom_5), All = as.numeric(All))

new_comptracks.df %>%
  pivot_longer(!Category, names_to = "Type", values_to = "Value") %>%
  ggplot(aes(x = Category, y = Value, fill = Type)) +
    ggtitle("Difference of Correlation and Mean of Popularity by Available Markets") +
    geom_bar(stat = "identity", color = "black", position = position_dodge()) +
    ylab("Value") +
    xlab("Variable") +
    scale_fill_brewer(palette = "Purples") +
    theme(
      plot.title = element_text(size = 16, hjust = 0.5),
      axis.text.y = element_text(size = 12),
      axis.text.x = element_text(angle = 45, vjust = 1, 
                                 size = 12, hjust = 1),
      axis.title.y = element_text(size = 14),
      axis.title.x = element_blank(),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      axis.ticks = element_blank())

## Plot of the differences of the previous data sets with the original data

diff.df <- data.frame(row.names(top_5cor), top_5cor, bt_5cor, bot_5cor)
new_diff.df <- rbind(diff.df, c("mean_difference", top_5mean_diff, bt_5mean_diff, bot_5mean_diff))
row.names(new_diff.df)[1:11] <- 1:11
names(new_diff.df) <- c("Category","Top_5", "All_5", "Bottom_5")

new_diff.df <- transform(new_diff.df[-11,], Top_5 = as.numeric(Top_5), All_5 = as.numeric(All_5), Bottom_5 = as.numeric(Bottom_5))

new_diff.df %>%
  pivot_longer(!Category, names_to = "Type", values_to = "Value") %>%
  ggplot(aes(x = Category, y = Value, fill = Type)) +
  ggtitle("Difference of Correlation and Mean of Popularity by Available Markets") +
  geom_bar(stat = "identity", color = "black", position = position_dodge()) +
  ylab("Difference from Population") +
  xlab("Variable") +
  scale_fill_brewer(palette = "Purples") +
  theme(
    plot.title = element_text(size = 16, hjust = 0.5),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(angle = 45, vjust = 1, 
                               size = 12, hjust = 1),
    axis.title.y = element_text(size = 14),
    axis.title.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.ticks = element_blank())
```

From the second plot we can see that the difference in the correlations for duration, energy, loudness and speechiness in the tracks that appear in all 5 of the top countries is the furthest from the correlations for the entire population. Danceability, tempo and, to a lesser degree, the popularity mean are closest to the population's for each country group. Noticeably, all of the differences, except for instrumentalness, share the same sign accross the groupings.

## Analysis of Popularity by Track's Country of Origin

We then want to look at the potential influence of where the track was originally created. The methodology will follow from the previous analysis, subsetting on the three countries listed in country.

```{r}
## Subsetting based on original country

table(tracks.df$country)

country_mean <- tracks.df[,-c(3,10)] %>%
  group_by(country) %>%
  summarise(mean(popularity)) %>%
  data.frame()

country_mean <- t(rbind(country_mean, c("All", mean(tracks.df$popularity))))

tracks_cor <- tracks_onlycontinuous.df %>% 
  correlate() %>% 
  focus(popularity)
tracks_cor <- data.frame(tracks_cor)
colnames(tracks_cor) <- c("Category", "All")

## Plotting the correlations versus popularity and mean popularity against country

country_tracks.df <- data.frame(row.names = tracks_cor$Category)

for (entry in unique(tracks.df$country)){
  country_cor <- tracks.df[,-c(3,10, 13)] %>%
    filter(country == entry) %>%
    select(which(sapply(., is.numeric))) %>%
    correlate() %>%
    focus(popularity) %>%
    data.frame()
  country_tracks.df[entry] <- country_cor[2]
}

country_tracks.df$All <- tracks_cor$All
country_tracks.df$Category <- row.names(country_tracks.df)
country_tracks.df <- rbind(country_tracks.df, country_mean[2,1:4])
country_tracks.df$Category[11] <- "mean"
row.names(country_tracks.df) <- 1:11

country_tracks.df <- transform(country_tracks.df, BE = as.numeric(BE), AR = as.numeric(AR), FI = as.numeric(FI), All = as.numeric(All))

country_tracks.df %>%
  pivot_longer(!Category, names_to = "Type", values_to = "Value") %>%
  ggplot(aes(x = Category, y = Value, fill = Type)) +
  ggtitle("Correlation Between Popularity and Mean Popularity by Country") +
  geom_bar(stat = "identity", color = "black", position = position_dodge()) +
  ylab("Value") +
  xlab("Variable") +
  scale_fill_brewer(palette = "YlGnBu") +
  theme(
    plot.title = element_text(size = 16, hjust = 0.5),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(angle = 45, vjust = 1, 
                               size = 12, hjust = 1),
    axis.title.y = element_text(size = 14),
    axis.title.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.ticks = element_blank())

## Plotting the differences

country_mean_diff <- tracks.df[,-c(3,10)] %>%
  group_by(country) %>%
  summarise(mean_pop = mean(tracks.df$popularity) - mean(popularity)) %>%
  data.frame()%>%
  t()

country_diff.df <- data.frame(row.names = tracks_cor$Category)

for (entry in unique(tracks.df$country)){
  country_diff <- tracks.df[,-c(3,10, 13)] %>%
  filter(country == entry) %>%
  select(which(sapply(., is.numeric))) %>%
  correlate() %>%
  focus(popularity) %>%
  data.frame()
  country_diff.df[entry] <- country_diff[2] - tracks_cor[2]
}

country_diff.df$Category <- row.names(country_diff.df)
country_diff.df <- rbind(country_diff.df, country_mean_diff[2,1:3])
country_diff.df$Category[11] <- "mean_difference"
row.names(country_diff.df) <- 1:11

country_diff.df <- transform(country_diff.df, BE = as.numeric(BE), AR = as.numeric(AR), FI = as.numeric(FI))

country_diff.df %>%
  pivot_longer(!Category, names_to = "Type", values_to = "Value") %>%
  ggplot(aes(x = Category, y = Value, fill = Type)) +
  ggtitle("Difference of Correlation and Mean of Popularity by Country") +
  geom_bar(stat = "identity", color = "black", position = position_dodge()) +
  ylab("Difference from Population") +
  xlab("Variable") +
  scale_fill_brewer(palette = "YlGnBu") +
  theme(
    plot.title = element_text(size = 16, hjust = 0.5),
    axis.text.y = element_text(size = 12),
    axis.text.x = element_text(angle = 45, vjust = 1, 
                               size = 12, hjust = 1),
    axis.title.y = element_text(size = 14),
    axis.title.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.ticks = element_blank())
```

By the looking at the plots we can see that in tracks from Belgium, the correlation between popularity and acousticness, loudness and speechiness are stronger than the population and the tracks are on average more popular than all other tracks (in the entire population and from one of the other country groups). Finland appears to have the most correlations closest to the population correlations with the exception of liveness where is has the lowest correlation with popularity. Songs from Finland also have the largest difference in average popularity and (rather sadly) are least popular by any group. Of the groups, Argentina has the highest correlation for instumentalness and duration.